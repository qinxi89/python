函数：
定义: 函数是指将一组语句的集合通过一个名字(函数名)封装起来，要想执行这个函数，只需调用其函数名即可

特性:
减少重复代码
使程序变的可扩展
使程序变得易维护

语法定义：
def qinxi():#函数名
    print("Hello, I'm nobody!")
 
qinxi() #调用函数

################################### 函数参数 ###################################
#位置参数：调用函数时根据函数定义的参数位置来传递参数。

形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只在函数内部有效。函数调用结束返回主调用函数后则不能再使用该形参变量
实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参。因此应预先用赋值，输入等办法使参数获得确定值
例子：
def calc(x,y):            #x,y为形参
    res = x**y
    return res #返回函数执行结果
 
c = calc(a,b)             ＃a, b 为实参
print(c)

################################## 默认参数   ########################################
#默认参数：用于定义函数，为参数提供默认值，调用函数时可传可不传该默认参数的值（注意：所有位置参数必须出现在默认参数前，包括函数定义和调用）

def stu_register(name, age , course,country="CN"):
    print("-----------注册学生信息")
    print("姓名：",name)
    print("年龄：",age)
    print("课程：", course)
    print("国籍：", country)

stu_register("qinxi",24, "英文","canada")
stu_register("cuihua",18,"match")
stu_register("jiaozi", 6,"linux")
注：
发现 country 这个参数 基本都 是"CN", 就像我们在网站上注册用户，像国籍这种信息，你不填写，默认就会是 中国， 这就是通过默认参数实现的，把country变成默认参数非常简单

def stu_register(name,age,course,country="CN"):
这样，这个参数在调用时不指定，那默认就是CN，如果指定了值，就用你指定的值。

###############################  关键参数  ##########################################
#关键字参数：通过“键-值”形式加以指定。

正常情况下，给函数传参数要按顺序，不想按顺序就可以用关键参数，只需指定参数名即可，但记住一个要求就是，关键参数必须放在位置参数之后。
stu_register(age=22,name='alex',course="python",)

##############################  可变参数 ##########################################
#可变参数： 定义函数时，有时候我们不确定调用的时候会传递多少个参数(不传参也可以)。此时，可用包裹(packing)位置参数，或者包裹关键字参数，来进行参数传递，会显得非常方便。
# 若你的函数在定义时不确定用户想传入多少个参数，就可以使用非固定参数
# A：  *args

def stu_regitster(name, age, *args):                #*args 会把多传入的参数变成一个元组形式
    print(name, age,args)

stu_regitster("xixi", 26)           #output:     xixi 26 ()     #后面这个（）就是args,只是因为没有传值，所以为空。
stu_regitster("xier", 36, "python","li")          #output:      xier 36 ('python', 'li')

# B：   **kwargs 会把多传入的参数变成一个dict形式。

def stu_register1(name, age, *args, **kwargs):
    print(name,age,args,kwargs)
stu_register1("qinxi", 22)              #output:     qinxi 22 () {}     #后面这个{} 就是kwargs,只是没有传值，所以为空。

stu_register1("jack", 32, "cn",  sex = "Male", provice = "HeNan")    #output: jack 32 ('cn', 'python') {'provice': 'HeNan', 'sex': 'Male'}
#注意：positional argument  after keyword argument 关键字参数一定要放到位置参数的后面，关键字参数之间不存在先后顺序的




######################################  函数的局部变量与全局变量  ###########################
全局与局部变量

在子程序中定义的变量称为局部变量，在程序的一开始定义的变量称为全局变量。
全局变量作用域是整个程序，局部变量作用域是定义该变量的子程序。
当全局变量与局部变量同名时：
在定义局部变量的子程序内，局部变量起作用；在其它地方全局变量起作用。

name = "qinxi"

def change_name(name):
    print("before name:",name)        #output：    before name: qinxi
    name = "翠花"                      
    print("after change", name)      #output:    after change 翠花

change_name(name)
print("在外面看看name改了吗",name)      #output:  在外面看看name改了吗 qinxi

####################################  函数返回值     ################################

要想获取函数的执行结果，就可以用return语句把结果返回

注意:

函数在执行过程中只要遇到return语句，就会停止执行并返回结果，so 也可以理解为 return 语句代表着函数的结束
如果未在函数中指定return,那这个函数的返回值为None

##################################### 递归函数   ##################################
在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。
递归特性:
1. 必须有一个明确的结束条件
2. 每次进入更深一层递归时，问题规模相比上次递归都应有所减少
3. 递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出）












